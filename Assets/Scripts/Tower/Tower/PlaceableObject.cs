using System.Collections;
using System.Collections.Generic;
using Unity.VisualScripting;
using UnityEngine;

public class PlaceableObject : MonoBehaviour
{
    // data에 있는 변수
    protected new string name;
    protected Sprite icon;
    protected float attackRange;
    protected float attackRoutine;
    protected float attackPower;
    protected int cost;

    // build되기 위한 변수
    public bool isInstalled = false;
    private bool isAttack = false;

    // attack하기 위한 변수
    protected Transform topTransform;   // target을 향해 고개를 돌릴 transform

    private Coroutine searchTargetCoroutine;
    protected Coroutine attackCoroutine;
    private WaitForSeconds searchSeconds;
    protected WaitForSeconds attackSeconds;

    private float updateIntervalTime;   // 타겟을 search할 간격
    private float minSqrDistance;       // 더 가까운 타겟을 공격하기 위한 최소 거리의 제곱

    protected Transform target;

    // Properties - shop item에서 사용하기 위함 -> 나중에 없애기 데이터만 가지고 관리
    public string Name { get { return name; } }
    public Sprite Icon { get { return icon; } }
    public int Cost { get { return cost; } }
    public float AttackPower { get { return attackPower; } }
    public float AttackRoutine { get { return attackRoutine; } }

    virtual protected void Start()
    {
        SetData();          // 자식에서 각각 자신의 data를 받아와 세팅해줌
        updateIntervalTime = 0.1f;
        searchSeconds = new WaitForSeconds(updateIntervalTime);
        attackSeconds = new WaitForSeconds(attackRoutine);
        if (isInstalled)
            searchTargetCoroutine = StartCoroutine(FindTargetDelay());
    }

    private void Update()
    {
        if (isInstalled)
            LookAtTarget();
    }

    private IEnumerator FindTargetDelay()
    {
        while (true)
        {
            yield return searchSeconds;
            // 최적화를 위해 코루틴을 사용해 0.1초마다 탐색하도록 구현
            FindTarget();
        }
    }

    private void FindTarget()
    {
        target = null; // 처음 target == null
        Collider[] colliders = Physics.OverlapSphere(this.transform.position, attackRange);

        for (int i = 0; i < colliders.Length; i++)
        {
            // 1. Enemy layer일 경우
            if (colliders[i].gameObject.layer != LayerMask.NameToLayer("Enemy"))
                continue;
            // 2. Target이 죽은 경우 -> layer가 DeadObject로 변환됨
            else if (colliders[i].gameObject.layer == LayerMask.NameToLayer("DeadObject"))
                continue;

            // 3. 앞에 장애물이 없을 경우 -> backGroundLayer에 가려졌을 경우 타겟으로 인식하지 못함
            Vector3 posDiffWithTarget = (colliders[i].gameObject.transform.position - this.transform.position);
            Vector3 dirToTarget = posDiffWithTarget.normalized;
            RaycastHit hit;
            if (Physics.Raycast(transform.position, dirToTarget, out hit, attackRange, LayerMask.NameToLayer("BackGround")))
            {
                continue;
            }

            // 4. 모든 조건 충족 -> IDamageable 오브젝트가 있는 경우만 타겟 설정 가능
            IDamageable damageableObj = colliders[i].GetComponent<IDamageable>();
            if (damageableObj != null)
            {
                // 타겟을 처음 찾았을 경우
                if (target == null)
                {
                    target = colliders[i].gameObject.transform;
                    float sqrDistanceToFirstTarget = posDiffWithTarget.sqrMagnitude;
                    minSqrDistance = sqrDistanceToFirstTarget;
                }
                else // 이전 타겟이 있었던 경우 거리 비교해서 거리가 더 짧은 오브젝트를 타겟으로 변경
                {
                    float sqrDistanceToTarget = posDiffWithTarget.sqrMagnitude;
                    if (sqrDistanceToTarget < minSqrDistance)
                    {
                        target = colliders[i].gameObject.transform;
                        minSqrDistance = sqrDistanceToTarget;
                    }
                }
            }
        }

        if(target != null && !isAttack) // 상태 설정 대신 bool 변수로 attack중임 인식
        {
            Attack();
            attackCoroutine = StartCoroutine(AttackDelay());
            isAttack = true;
        }
        else if(target == null && isAttack)
        {
            StopCoroutine(attackCoroutine);
            isAttack = false;
        }
    }
    protected void LookAtTarget()
    {
        if (target != null)
        {
            // target을 바라보도록 구현
            topTransform.LookAt(target);

            // 타겟을 향한 ray 그리기
            Vector3 posDiffWithTarget = target.gameObject.transform.position - this.transform.position;
            Debug.DrawRay(transform.position, posDiffWithTarget, Color.yellow);
        }
    }
    virtual protected IEnumerator AttackDelay()
    {
        while (true)
        {
            yield return attackSeconds;
            // TODO : Attack 함수는 child에서 재정의
            Attack();
        }
    }
    public void Sell() // -> 나중에 shop으로 할지 생각
    {
        PlayerStatManager.Instance.MoneyChange((int)(cost * 0.5));
    }

    virtual protected void Attack() { }

    virtual protected void SetData() { }

    virtual protected void OnDrawGizmos()
    {
        if (target == null)
            Gizmos.color = Color.cyan;
        else
            Gizmos.color = Color.red;
        Gizmos.DrawWireSphere(transform.position, attackRange);
    }
}
